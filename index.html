<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dynamic GIF Command-Line | FunnelFunction</title>
  <meta name="description" content="Self-resolving visual computation engine. Create brand-consistent graphics through mathematical convergence. Built on Intent Tensor Theory.">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
      --bg-primary: #0a0a0f;
      --bg-secondary: #13131a;
      --bg-tertiary: #1a1a24;
      --text-primary: #e8e8f0;
      --text-secondary: #a0a0b8;
      --text-tertiary: #70708c;
      --accent-cyan: #00d4ff;
      --accent-purple: #7b61ff;
      --accent-green: #00ff88;
      --accent-red: #ff3366;
      --accent-orange: #ff8c00;
      --font-mono: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    }
    
    body {
      font-family: var(--font-mono);
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem;
    }
    
    /* Header */
    .header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .header h1 {
      font-size: 1.5rem;
      color: var(--accent-cyan);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }
    
    .header p {
      color: var(--text-secondary);
      font-size: 0.875rem;
    }
    
    /* Terminal */
    .terminal {
      width: 100%;
      max-width: 900px;
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
    }
    
    .terminal-header {
      display: flex;
      gap: 8px;
      margin-bottom: 1rem;
    }
    
    .terminal-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
    
    .terminal-dot.red { background: #ff5f56; }
    .terminal-dot.yellow { background: #ffbd2e; }
    .terminal-dot.green { background: #27ca40; }
    
    .command-line {
      display: flex;
      align-items: center;
    }
    
    .command-prefix {
      color: var(--accent-cyan);
      margin-right: 8px;
      font-weight: bold;
    }
    
    #command-input {
      width: 100%;
      background: transparent;
      border: none;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 1rem;
      outline: none;
    }
    
    #command-input::placeholder {
      color: var(--text-tertiary);
    }
    
    /* Status */
    .status {
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 1rem;
      font-size: 0.875rem;
      max-width: 900px;
      width: 100%;
    }
    
    .status.success {
      background: rgba(0, 255, 136, 0.1);
      border: 1px solid var(--accent-green);
      color: var(--accent-green);
    }
    
    .status.error {
      background: rgba(255, 51, 102, 0.1);
      border: 1px solid var(--accent-red);
      color: var(--accent-red);
    }
    
    .status.info {
      background: rgba(0, 212, 255, 0.1);
      border: 1px solid var(--accent-cyan);
      color: var(--accent-cyan);
    }
    
    .status.hidden { display: none; }
    
    /* Canvas */
    .canvas-container {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      max-width: 900px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    #preview-canvas {
      display: block;
      max-width: 100%;
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }
    
    /* Actions */
    .actions {
      display: flex;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }
    
    .btn {
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      border: none;
      font-family: inherit;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 600;
    }
    
    .btn-primary {
      background: var(--accent-cyan);
      color: var(--bg-primary);
    }
    
    .btn-primary:hover {
      background: #00b8e0;
      transform: translateY(-2px);
    }
    
    .btn-secondary {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--text-tertiary);
    }
    
    .btn-secondary:hover {
      border-color: var(--accent-cyan);
      color: var(--accent-cyan);
    }
    
    /* Quick Examples */
    .examples {
      width: 100%;
      max-width: 900px;
      margin-top: 1rem;
    }
    
    .examples h3 {
      color: var(--text-secondary);
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 1rem;
    }
    
    .example-category {
      margin-bottom: 1.5rem;
    }
    
    .example-category h4 {
      color: var(--accent-purple);
      font-size: 0.8rem;
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .example-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .example-item {
      background: var(--bg-secondary);
      padding: 0.75rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.875rem;
      color: var(--text-secondary);
      border: 1px solid transparent;
    }
    
    .example-item:hover {
      background: var(--bg-tertiary);
      color: var(--accent-cyan);
      border-color: var(--accent-cyan);
    }
    
    .example-item .label {
      color: var(--accent-green);
      margin-right: 0.5rem;
    }
    
    .example-item .desc {
      color: var(--text-tertiary);
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }
    
    /* Palette definitions */
    .palettes {
      display: none; /* Hidden, just for reference */
    }
    
    /* Footer */
    .footer {
      margin-top: 2rem;
      text-align: center;
      color: var(--text-tertiary);
      font-size: 0.75rem;
    }
    
    .footer a {
      color: var(--accent-cyan);
      text-decoration: none;
    }
    
    .footer a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <!-- Header -->
  <div class="header">
    <h1>‚ö° DYNAMIC GIF COMMAND-LINE</h1>
    <p>URL ‚Üí Manifest ‚Üí Emergence ‚Üí GIF</p>
    <p style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-tertiary);">
      Built on Intent Tensor Theory | <a href="https://intent-tensor-theory.com" style="color: var(--accent-purple);">ITT Docs</a>
    </p>
  </div>

  <!-- Terminal -->
  <div class="terminal">
    <div class="terminal-header">
      <div class="terminal-dot red"></div>
      <div class="terminal-dot yellow"></div>
      <div class="terminal-dot green"></div>
    </div>
    <div class="command-line">
      <span class="command-prefix">#</span>
      <input 
        type="text" 
        id="command-input" 
        placeholder="text=Hello World|scene=gradient|palette=oceanic"
        autocomplete="off"
        spellcheck="false"
      >
    </div>
  </div>

  <!-- Status -->
  <div id="status" class="status info">
    üí° Type a command or click an example below to generate a GIF
  </div>

  <!-- Canvas -->
  <div class="canvas-container">
    <canvas id="preview-canvas" width="400" height="400"></canvas>
    <!-- Hidden GIF preview that shows when animation is ready -->
    <img id="gif-preview" style="display: none; max-width: 100%; border-radius: 8px; box-shadow: 0 8px 32px rgba(0,0,0,0.4);" />
  </div>

  <!-- Actions -->
  <div class="actions">
    <button class="btn btn-primary" id="render-btn">Render GIF</button>
    <button class="btn btn-secondary" id="preview-gif-btn" style="display: none;">Preview Animation</button>
    <button class="btn btn-secondary" id="download-btn">Download</button>
  </div>

  <!-- Quick Examples Library -->
  <div class="examples">
    <h3>üé® QUICK EXAMPLES LIBRARY</h3>
    
    <!-- Simple Static -->
    <div class="example-category">
      <h4>üìù SIMPLE STATIC (Single Text)</h4>
      <div class="example-list">
        <div class="example-item" data-cmd="text=Hello World">
          <span class="label">Minimal:</span> Hello World
          <div class="desc">Basic centered text, default styling</div>
        </div>
        <div class="example-item" data-cmd="text=FunnelFunction|scene=gradient|palette=oceanic">
          <span class="label">Brand:</span> Oceanic Gradient
          <div class="desc">Blue-teal gradient with brand text</div>
        </div>
        <div class="example-item" data-cmd="text=Innovation Drives Us|scene=gradient|palette=sunset">
          <span class="label">Warm:</span> Sunset Theme
          <div class="desc">Orange-red warm gradient</div>
        </div>
        <div class="example-item" data-cmd="text=Tech Excellence|scene=corporate|palette=midnight">
          <span class="label">Corporate:</span> Midnight Blue
          <div class="desc">Professional dark blue corporate style</div>
        </div>
        <div class="example-item" data-cmd="text=Grow Your Business|scene=gradient|palette=forest">
          <span class="label">Natural:</span> Forest Green
          <div class="desc">Fresh green nature-inspired theme</div>
        </div>
      </div>
    </div>
    
    <!-- Canvas Sizes -->
    <div class="example-category">
      <h4>üìê CANVAS SIZES (Aspect Ratios)</h4>
      <div class="example-list">
        <div class="example-item" data-cmd="text=Instagram Post|scene=gradient|palette=sunset|canvas=1:1">
          <span class="label">Square:</span> 1:1 Instagram/Social
          <div class="desc">Perfect for social media posts</div>
        </div>
        <div class="example-item" data-cmd="text=YouTube Thumbnail|scene=gradient|palette=oceanic|canvas=16:9">
          <span class="label">Wide:</span> 16:9 YouTube/Video
          <div class="desc">YouTube thumbnails, video content</div>
        </div>
        <div class="example-item" data-cmd="text=Story/Reel|scene=gradient|palette=midnight|canvas=9:16">
          <span class="label">Vertical:</span> 9:16 Stories/Reels
          <div class="desc">Instagram Stories, TikTok, Reels</div>
        </div>
        <div class="example-item" data-cmd="text=Pinterest Pin|scene=gradient|palette=forest|canvas=2:3">
          <span class="label">Tall:</span> 2:3 Pinterest
          <div class="desc">Pinterest pins, portrait content</div>
        </div>
      </div>
    </div>
    
    <!-- Multi-Line Layouts -->
    <div class="example-category">
      <h4>üìÑ MULTI-LINE LAYOUTS (Company + Tagline)</h4>
      <div class="example-list">
        <div class="example-item" data-cmd="text=FunnelFunction\nB2B Lead Generation|scene=gradient|palette=oceanic">
          <span class="label">Brand + Tagline:</span> Two-line stack
          <div class="desc">Company name with tagline below</div>
        </div>
        <div class="example-item" data-cmd="text=ACME Corp\nInnovation ‚Ä¢ Excellence ‚Ä¢ Growth|scene=corporate|palette=midnight">
          <span class="label">Corporate:</span> Brand + Values
          <div class="desc">Professional with bullet-separated values</div>
        </div>
        <div class="example-item" data-cmd="text=Q4 2025\nRevenue Report|scene=gradient|palette=forest|canvas=16:9">
          <span class="label">Report:</span> Title + Subtitle
          <div class="desc">Clean report cover style</div>
        </div>
        <div class="example-item" data-cmd="text=Armstrong Knight\nCEO & Founder|scene=gradient|palette=sunset">
          <span class="label">Executive:</span> Name + Title
          <div class="desc">Leadership/speaker introduction</div>
        </div>
      </div>
    </div>
    
    <!-- Service Showcases -->
    <div class="example-category">
      <h4>üõ†Ô∏è SERVICE SHOWCASES (Feature Lists)</h4>
      <div class="example-list">
        <div class="example-item" data-cmd="text=Our Services\n‚Ä¢ Lead Generation\n‚Ä¢ Email Automation\n‚Ä¢ Analytics|scene=gradient|palette=oceanic">
          <span class="label">Services:</span> Bullet List
          <div class="desc">Service offering with bullet points</div>
        </div>
        <div class="example-item" data-cmd="text=FunnelFunction\n‚úì Scrape Leads\n‚úì Verify Emails\n‚úì Auto Outreach|scene=gradient|palette=forest">
          <span class="label">Features:</span> Checkmark List
          <div class="desc">Feature list with checkmarks</div>
        </div>
        <div class="example-item" data-cmd="text=Why Choose Us?\n‚Üí AI Powered\n‚Üí 10x Faster\n‚Üí 80% Cost Savings|scene=gradient|palette=sunset">
          <span class="label">Benefits:</span> Arrow List
          <div class="desc">Value proposition with arrows</div>
        </div>
      </div>
    </div>
    
    <!-- Statistics & Numbers -->
    <div class="example-category">
      <h4>üìä STATISTICS & NUMBERS</h4>
      <div class="example-list">
        <div class="example-item" data-cmd="text=10,000+\nLeads Generated|scene=gradient|palette=oceanic|canvas=1:1">
          <span class="label">Big Number:</span> Stat + Label
          <div class="desc">Impressive statistic highlight</div>
        </div>
        <div class="example-item" data-cmd="text=Revenue Up\n+47%|scene=gradient|palette=forest">
          <span class="label">Growth:</span> Percentage Gain
          <div class="desc">Growth metric announcement</div>
        </div>
        <div class="example-item" data-cmd="text=$2.4M ARR\nQ4 2025|scene=corporate|palette=midnight">
          <span class="label">Financial:</span> ARR Milestone
          <div class="desc">Financial milestone announcement</div>
        </div>
      </div>
    </div>
    
    <!-- Call to Actions -->
    <div class="example-category">
      <h4>üéØ CALL TO ACTIONS</h4>
      <div class="example-list">
        <div class="example-item" data-cmd="text=Start Free Trial\nNo Credit Card Required|scene=gradient|palette=oceanic">
          <span class="label">CTA:</span> Free Trial
          <div class="desc">Conversion-focused with reassurance</div>
        </div>
        <div class="example-item" data-cmd="text=Book a Demo\nSee It In Action|scene=gradient|palette=sunset">
          <span class="label">CTA:</span> Demo Request
          <div class="desc">Demo booking prompt</div>
        </div>
        <div class="example-item" data-cmd="text=Limited Offer\n50% OFF Today Only|scene=gradient|palette=sunset">
          <span class="label">Urgency:</span> Flash Sale
          <div class="desc">Limited time offer with urgency</div>
        </div>
      </div>
    </div>
    
    <!-- Event & Announcements -->
    <div class="example-category">
      <h4>üì¢ EVENTS & ANNOUNCEMENTS</h4>
      <div class="example-list">
        <div class="example-item" data-cmd="text=üöÄ NEW FEATURE\nAI Email Writer|scene=gradient|palette=oceanic">
          <span class="label">Launch:</span> Feature Announcement
          <div class="desc">New feature launch graphic</div>
        </div>
        <div class="example-item" data-cmd="text=WEBINAR\nJan 15, 2025 @ 2PM EST|scene=gradient|palette=midnight">
          <span class="label">Event:</span> Webinar Promo
          <div class="desc">Event date and time announcement</div>
        </div>
        <div class="example-item" data-cmd="text=üéâ WE'RE HIRING!\nJoin Our Team|scene=gradient|palette=forest">
          <span class="label">Hiring:</span> Recruitment
          <div class="desc">Job opening announcement</div>
        </div>
        <div class="example-item" data-cmd="text=Version 2.0\nNow Available|scene=gradient|palette=sunset">
          <span class="label">Release:</span> Version Launch
          <div class="desc">Software version release</div>
        </div>
      </div>
    </div>
    
    <!-- Quotes & Testimonials -->
    <div class="example-category">
      <h4>üí¨ QUOTES & TESTIMONIALS</h4>
      <div class="example-list">
        <div class="example-item" data-cmd="text=\"Best lead gen tool we've used\"\n‚Äî Sarah Chen, VP Sales|scene=gradient|palette=oceanic">
          <span class="label">Testimonial:</span> Customer Quote
          <div class="desc">Customer testimonial with attribution</div>
        </div>
        <div class="example-item" data-cmd="text=Think Different.\n‚Äî Steve Jobs|scene=minimal|palette=midnight">
          <span class="label">Inspiration:</span> Famous Quote
          <div class="desc">Inspirational quote attribution</div>
        </div>
      </div>
    </div>
    
    <!-- Complex Multi-Frame (Coming Soon) -->
    <div class="example-category">
      <h4>üé¨ MULTI-FRAME ANIMATED SEQUENCES</h4>
      <div class="example-list">
        <div class="example-item" data-cmd="sequence=Consultations~Build Apps~Scale Fast~Profit üí∞|palette=oceanic|timing=2s">
          <span class="label">Services:</span> 4-Frame Business Sequence
          <div class="desc">Animated service showcase (use ~ to separate frames)</div>
        </div>
        <div class="example-item" data-cmd="sequence=Q4 Results~Revenue Up 23%~Expanding Markets~2025 Outlook|palette=midnight|timing=3s">
          <span class="label">Corporate:</span> Quarterly Report Animation
          <div class="desc">Professional 4-frame announcement</div>
        </div>
        <div class="example-item" data-cmd="sequence=üöÄ Launching Soon~New Features~Better UX~Coming January|palette=sunset|timing=1.5s">
          <span class="label">Launch:</span> Product Teaser
          <div class="desc">Excitement-building reveal sequence</div>
        </div>
        <div class="example-item" data-cmd="sequence=Step 1: Sign Up~Step 2: Connect~Step 3: Launch~Step 4: Profit!|palette=forest|timing=2s">
          <span class="label">Tutorial:</span> How It Works
          <div class="desc">Step-by-step process animation</div>
        </div>
        <div class="example-item" data-cmd="sequence=10,000+~Leads Generated~Every Month~FunnelFunction|palette=oceanic|timing=1s">
          <span class="label">Stats:</span> Metric Animation
          <div class="desc">Fast-paced statistic showcase</div>
        </div>
        <div class="example-item" data-cmd="sequence=Hello~We Are~FunnelFunction~Let's Build Together|palette=purple|timing=1.5s|canvas=16:9">
          <span class="label">Intro:</span> Brand Introduction
          <div class="desc">Widescreen brand animation</div>
        </div>
      </div>
    </div>
    
    <!-- Zone-Based Layouts (Advanced) -->
    <div class="example-category">
      <h4>üèóÔ∏è ZONE-BASED LAYOUTS (Professional Ads)</h4>
      <div class="example-list">
        <div class="example-item" data-cmd="header=FunnelFunction|subheader=Lead Generation|content=Email Automation~CRM Integration~Analytics Dashboard~Conversion Tracking|footer=funnelfunction.com|decorations=corners,squares|timing=2s">
          <span class="label">Corporate:</span> FunnelFunction Services
          <div class="desc">Fixed header/footer, animated services</div>
        </div>
        <div class="example-item" data-cmd="header=TechCorp|subheader=Solutions|content=Web Development~Mobile Apps~Cloud Services~AI Integration|footer=techcorp.io|decorations=corners|subheaderColor=#00ff00|timing=1.5s">
          <span class="label">Tech:</span> Service Showcase
          <div class="desc">Green accent, corner brackets</div>
        </div>
        <div class="example-item" data-cmd="header=Mayo Clinic|subheader=Primary Care|content=Internal Medicine~Family Health~Preventive Care~Wellness Programs|tagline=The Needs of the Patient Come First|footer=mayoclinic.org|decorations=corners,circles|subheaderColor=#00ff00|timing=2.5s">
          <span class="label">Healthcare:</span> Medical Services
          <div class="desc">Full zone layout with tagline</div>
        </div>
        <div class="example-item" data-cmd="header=Amazon|subheader=Prime|content=Free Shipping~Video Streaming~Music Unlimited~Exclusive Deals|decorations=corners,circles|backgroundColor=#1a1a1a|subheaderColor=#00ff00|timing=2s">
          <span class="label">Brand:</span> Amazon Prime
          <div class="desc">Dark theme, centered circles</div>
        </div>
        <div class="example-item" data-cmd="header=Future Tech|subheader=AI Automations|content=Machine Learning~Neural Networks~Computer Vision~NLP Solutions|tagline=We build tomorrow|footer=future.tech|background=gradient|palette=sunset|decorations=corners,circles|timing=2s">
          <span class="label">AI:</span> Future Tech
          <div class="desc">Gradient background with decorations</div>
        </div>
        <div class="example-item" data-cmd="header=StartupName|subheader=Expert Consulting|content=Strategy~Development~Marketing~Growth|decorations=corners,pinstripes|backgroundColor=#1a1a3a|subheaderColor=#00d4ff|decorationColor=#7b61ff|timing=1.5s">
          <span class="label">Startup:</span> Consulting Services  
          <div class="desc">Purple pinstripes, cyan accent</div>
        </div>
      </div>
    </div>
    
    <!-- Scalar Unfurling - Advanced Decorations -->
    <div class="example-category">
      <h4>üî¢ SCALAR UNFURLING (ITT Mathematical Patterns)</h4>
      <p style="font-size: 0.75rem; color: #888; margin-bottom: 0.5rem; padding: 0 0.5rem;">
        Each scalar (angle, spacing) unfurls through mathematical projection into visual reality.
        Œ∏ ‚Üí (cos Œ∏, sin Œ∏) ‚Üí line family ‚Üí pixels. Minimal input ‚Üí maximum specification.
      </p>
      <div class="example-list">
        <div class="example-item" data-cmd="header=Gradient Co|subheader=‚àáŒ¶ Fields|content=Linear Flow~Directional Force~Vector Space|decorations=corners,diagonals|angle=30|spacing=50|backgroundColor=#0a0a1a|decorationColor=#00ffaa|timing=2s">
          <span class="label">30¬∞ Diagonals:</span> Shallow Gradient Field
          <div class="desc">angle=30 unfurls into southwest‚Üínortheast lines</div>
        </div>
        <div class="example-item" data-cmd="header=CrossField|subheader=Superposition|content=Wave 1~Wave 2~Interference|decorations=corners,crosshatch|angle=60|angle2=120|spacing=35|backgroundColor=#1a1a2e|decorationColor=#ff6b6b|timing=2s">
          <span class="label">Crosshatch:</span> Dual Field Interference
          <div class="desc">Two ‚àáŒ¶ fields at 60¬∞ and 120¬∞ superimposed</div>
        </div>
        <div class="example-item" data-cmd="header=GridSpace|subheader=Cartesian Basis|content=e‚ÇÅ Axis~e‚ÇÇ Axis~Origin|decorations=corners,grid|spacing=30|backgroundColor=#0f0f1a|decorationColor=#4a9eff|timing=1.5s">
          <span class="label">Grid:</span> Orthogonal Coordinate Field
          <div class="desc">x=const ‚à© y=const level sets</div>
        </div>
        <div class="example-item" data-cmd="header=Radial|subheader=Level Sets|content=r = 40~r = 70~r = 100|decorations=corners,rings|backgroundColor=#1a0a1a|decorationColor=#ff00ff|timing=2s">
          <span class="label">Rings:</span> Concentric Equipotential Surfaces
          <div class="desc">Multiple radii from single center point</div>
        </div>
        <div class="example-item" data-cmd="header=Starburst|subheader=Ray Field|content=Œ∏ = 0¬∞~Œ∏ = 30¬∞~Œ∏ = 60¬∞~Œ∏ = 90¬∞|decorations=corners,burst|backgroundColor=#1a1a0a|decorationColor=#ffcc00|timing=1.5s">
          <span class="label">Burst:</span> Angular Direction Field
          <div class="desc">12 rays emanating from center</div>
        </div>
        <div class="example-item" data-cmd="header=Sine|subheader=Oscillation|content=Peak~Trough~Zero Crossing|decorations=corners,wave|amplitude=30|wavelength=80|backgroundColor=#0a1a1a|decorationColor=#00ffff|timing=2s">
          <span class="label">Wave:</span> Sinusoidal Field
          <div class="desc">y = A¬∑sin(kx) where k = 2œÄ/Œª</div>
        </div>
        <div class="example-item" data-cmd="header=Dots Array|subheader=Discrete Sampling|content=Point 1~Point 2~Point 3|decorations=corners,dots|spacing=25|backgroundColor=#1a1a1a|decorationColor=#88ff88|timing=1.5s">
          <span class="label">Dots:</span> Lattice Point Sampling
          <div class="desc">Œ¶ evaluated at regular grid points</div>
        </div>
        <div class="example-item" data-cmd="header=Full Stack|subheader=Layer Composition|content=Background~Patterns~Shapes~Text|decorations=corners,diagonals,circles,squares|angle=45|spacing=60|backgroundColor=#0f0f2a|decorationColor=#00ff88|timing=2s">
          <span class="label">Full Stack:</span> All Layers Combined
          <div class="desc">Complete scalar unfurling demonstration</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Footer -->
  <div class="footer">
    <p>
      Built by <a href="https://funnelfunction.com">Armstrong Knight & Abdullah Khan</a> |
      Powered by <a href="https://intent-tensor-theory.com">Intent Tensor Theory</a>
    </p>
    <p style="margin-top: 0.5rem;">
      AI Collaboration: Claude (Anthropic), ChatGPT (OpenAI), Grok (xAI), Gemini (Google)
    </p>
    <p style="margin-top: 0.5rem;">
      <a href="https://github.com/FunnelFunction/0.0_Dynamic_GIF_Command-Line">GitHub Repository</a>
    </p>
  </div>

  <script>
    /**
     * DYNAMIC GIF COMMAND-LINE ENGINE
     * 
     * Self-resolving visual computation through mathematical convergence.
     * Based on Intent Tensor Theory (ITT) coordinate system.
     * 
     * Collapse Genesis Stack: Œ¶ ‚Üí ‚àáŒ¶ ‚Üí ‚àá√óF ‚Üí ‚àá¬≤Œ¶ ‚Üí œÅq
     */

    // Color Palettes - Brand Attractors
    const PALETTES = {
      oceanic: {
        gradient: ['#0066cc', '#00aacc', '#00ccaa'],
        text: '#ffffff',
        name: 'Oceanic'
      },
      sunset: {
        gradient: ['#ff6b35', '#f7931a', '#ffcc00'],
        text: '#ffffff',
        name: 'Sunset'
      },
      midnight: {
        gradient: ['#1a1a2e', '#16213e', '#0f3460'],
        text: '#e8e8f0',
        name: 'Midnight'
      },
      forest: {
        gradient: ['#134e5e', '#1a8a5a', '#2ecc71'],
        text: '#ffffff',
        name: 'Forest'
      },
      purple: {
        gradient: ['#667eea', '#764ba2', '#f093fb'],
        text: '#ffffff',
        name: 'Purple'
      },
      minimal: {
        gradient: ['#ffffff', '#f8f9fa', '#e9ecef'],
        text: '#1a1a2e',
        name: 'Minimal'
      },
      corporate: {
        gradient: ['#2c3e50', '#3498db', '#2980b9'],
        text: '#ffffff',
        name: 'Corporate'
      },
      neon: {
        gradient: ['#0a0a0f', '#1a1a2e', '#0a0a0f'],
        text: '#00ff88',
        name: 'Neon'
      }
    };

    // Canvas aspect ratios
    const CANVAS_SIZES = {
      '1:1': { width: 400, height: 400 },
      '16:9': { width: 640, height: 360 },
      '9:16': { width: 360, height: 640 },
      '4:3': { width: 480, height: 360 },
      '2:3': { width: 400, height: 600 },
      '4:5': { width: 400, height: 500 }
    };

    // DOM Elements
    const commandInput = document.getElementById('command-input');
    const statusEl = document.getElementById('status');
    const canvas = document.getElementById('preview-canvas');
    const ctx = canvas.getContext('2d');
    const renderBtn = document.getElementById('render-btn');
    const downloadBtn = document.getElementById('download-btn');

    // Current state
    let currentManifest = null;
    let gifData = null;

    /**
     * Parse command string into manifest
     * Supports: sequence=Frame1|Frame2|Frame3 for multi-frame
     */
    function parseCommand(cmdStr) {
      const manifest = {
        text: 'Hello World',
        scene: 'gradient',
        palette: 'oceanic',
        canvas: '1:1',
        animation: 'none',
        sequence: null,
        timing: 2000, // ms per frame
        loop: true
      };

      // Split by | but preserve sequence values
      // First check if there's a sequence parameter
      const sequenceMatch = cmdStr.match(/sequence=([^|]+(?:\|[^|=]+)*?)(?=\|[a-zA-Z]+=|$)/);
      if (sequenceMatch) {
        // Extract sequence frames (split by ~ for sequence separator)
        manifest.sequence = sequenceMatch[1].split('~').map(s => s.trim());
        // Remove sequence from cmdStr for further parsing
        cmdStr = cmdStr.replace(sequenceMatch[0], '');
      }

      // Split by | and parse each param
      const parts = cmdStr.split('|').filter(p => p.trim());
      for (const part of parts) {
        const [key, ...valueParts] = part.split('=');
        const value = valueParts.join('='); // Handle = in value
        if (key && value) {
          const k = key.trim();
          const v = value.trim();
          
          if (k === 'timing') {
            // Parse timing: "2s" -> 2000, "500ms" -> 500
            if (v.endsWith('s') && !v.endsWith('ms')) {
              manifest.timing = parseFloat(v) * 1000;
            } else if (v.endsWith('ms')) {
              manifest.timing = parseFloat(v);
            } else {
              manifest.timing = parseFloat(v) * 1000; // Default to seconds
            }
          } else if (k === 'loop') {
            manifest.loop = v !== 'false' && v !== '0';
          } else {
            manifest[k] = v;
          }
        }
      }

      // Handle newlines in text (convert \n to actual newlines)
      manifest.text = manifest.text.replace(/\\n/g, '\n');

      return manifest;
    }

    /**
     * Emerge full specification from minimal manifest
     * (Fiber bundle projection: 5 inputs ‚Üí 50+ properties)
     */
    function emerge(manifest) {
      const palette = PALETTES[manifest.palette] || PALETTES.oceanic;
      const canvasSize = CANVAS_SIZES[manifest.canvas] || CANVAS_SIZES['1:1'];

      return {
        ...manifest,
        colors: palette,
        dimensions: canvasSize,
        typography: {
          fontFamily: 'Inter, -apple-system, BlinkMacSystemFont, sans-serif',
          fontSize: calculateFontSize(manifest.text, canvasSize),
          fontWeight: 700,
          lineHeight: 1.3,
          textAlign: 'center'
        },
        layout: {
          x: canvasSize.width / 2,
          y: canvasSize.height / 2,
          padding: 40,
          maxWidth: canvasSize.width - 80
        }
      };
    }

    /**
     * Calculate optimal font size based on text and canvas
     */
    function calculateFontSize(text, canvasSize) {
      const lines = text.split('\n');
      const maxLineLength = Math.max(...lines.map(l => l.length));
      const lineCount = lines.length;
      
      // Base size on canvas width and text length
      let baseSize = Math.min(canvasSize.width, canvasSize.height) / 8;
      
      // Reduce for longer text
      if (maxLineLength > 20) baseSize *= 0.7;
      if (maxLineLength > 30) baseSize *= 0.7;
      if (lineCount > 2) baseSize *= 0.85;
      if (lineCount > 4) baseSize *= 0.8;
      
      return Math.max(16, Math.min(baseSize, 72));
    }

    /**
     * Word wrap text to fit within maxWidth
     */
    function wrapText(ctx, text, maxWidth) {
      const lines = text.split('\n');
      const wrappedLines = [];
      
      for (const line of lines) {
        const words = line.split(' ');
        let currentLine = '';
        
        for (const word of words) {
          const testLine = currentLine + (currentLine ? ' ' : '') + word;
          const metrics = ctx.measureText(testLine);
          
          if (metrics.width > maxWidth && currentLine) {
            wrappedLines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = testLine;
          }
        }
        
        if (currentLine) {
          wrappedLines.push(currentLine);
        }
      }
      
      return wrappedLines;
    }

    /**
     * Render a single frame to canvas
     * @param {Object} spec - Emerged specification
     * @param {string} textOverride - Optional text override for sequence frames
     * @returns {ImageData} - Rendered frame data
     */
    function renderFrame(spec, textOverride = null) {
      const { dimensions, colors, typography, layout } = spec;
      const text = textOverride || spec.text;
      
      // Resize canvas
      canvas.width = dimensions.width;
      canvas.height = dimensions.height;
      
      // Draw gradient background
      const gradient = ctx.createLinearGradient(0, 0, dimensions.width, dimensions.height);
      colors.gradient.forEach((color, i) => {
        gradient.addColorStop(i / (colors.gradient.length - 1), color);
      });
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, dimensions.width, dimensions.height);
      
      // Recalculate font size for this specific text
      const fontSize = calculateFontSize(text, dimensions);
      
      // Configure text
      ctx.fillStyle = colors.text;
      ctx.font = `${typography.fontWeight} ${fontSize}px ${typography.fontFamily}`;
      ctx.textAlign = typography.textAlign;
      ctx.textBaseline = 'middle';
      
      // Wrap text to fit
      const wrappedLines = wrapText(ctx, text, layout.maxWidth);
      const lineHeight = fontSize * typography.lineHeight;
      const totalHeight = wrappedLines.length * lineHeight;
      const startY = layout.y - totalHeight / 2 + lineHeight / 2;
      
      // Draw each line
      wrappedLines.forEach((line, i) => {
        ctx.fillText(line, layout.x, startY + i * lineHeight);
      });
      
      return ctx.getImageData(0, 0, dimensions.width, dimensions.height);
    }

    /**
     * Render to canvas (single frame - backward compatible)
     */
    function render(spec) {
      renderFrame(spec);
      return canvas;
    }

    /**
     * ============================================
     * ZONE-BASED LAYOUT SYSTEM
     * Fixed zones + animated content zone
     * ============================================
     */
    
    /**
     * ============================================
     * DECORATION SYSTEM - Scalar Field Geometry
     * 
     * Each decoration is a COLLAPSE PATTERN in the visual field.
     * Following ITT: Œ¶ ‚Üí ‚àáŒ¶ ‚Üí ‚àá√óF ‚Üí ‚àá¬≤Œ¶
     * 
     * Lines     = ‚àáŒ¶ (gradient direction - linear collapse along vector)
     * Circles   = Radial harmonic (spherical collapse from point source)
     * Squares   = Orthogonal collapse (Cartesian basis vectors e‚ÇÅ, e‚ÇÇ)
     * Gradients = |Œ¶| magnitude (field intensity visualization)
     * Angles    = SO(2) rotation of ‚àáŒ¶ through angle Œ∏
     * 
     * The SCALAR UNFURLING:
     * A parameter like `angle=45` is a single scalar.
     * It unfurls through fiber bundle projection:
     *   Œ∏ ‚Üí (cos Œ∏, sin Œ∏) ‚Üí parametric curve ‚Üí pixel coordinates
     * 
     * This is the Pre-Emergent Visual Dynamics principle:
     * Minimal input ‚Üí Maximum specification through mathematical emergence
     * ============================================
     */
    
    const Decorations = {
      
      /**
       * CORNERS - Orthogonal Collapse at Boundaries
       * Mathematical basis: L-shaped paths at canvas vertices
       * Each corner is a ‚àá¬≤Œ¶ collapse point where field intensity peaks
       */
      corners: (ctx, w, h, color, thickness = 2, size = 30) => {
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness;
        const margin = 15;
        
        // Four corners = four collapse vertices
        // Top-left: origin anchor
        ctx.beginPath();
        ctx.moveTo(margin, margin + size);
        ctx.lineTo(margin, margin);
        ctx.lineTo(margin + size, margin);
        ctx.stroke();
        
        // Top-right: x-reflection
        ctx.beginPath();
        ctx.moveTo(w - margin - size, margin);
        ctx.lineTo(w - margin, margin);
        ctx.lineTo(w - margin, margin + size);
        ctx.stroke();
        
        // Bottom-left: y-reflection  
        ctx.beginPath();
        ctx.moveTo(margin, h - margin - size);
        ctx.lineTo(margin, h - margin);
        ctx.lineTo(margin + size, h - margin);
        ctx.stroke();
        
        // Bottom-right: xy-reflection (point inversion)
        ctx.beginPath();
        ctx.moveTo(w - margin - size, h - margin);
        ctx.lineTo(w - margin, h - margin);
        ctx.lineTo(w - margin, h - margin - size);
        ctx.stroke();
      },
      
      /**
       * CIRCLES - Radial Collapse from Point Sources
       * Mathematical basis: r = constant (level sets of radial distance)
       * Each circle is a resonance ring - equidistant from center
       * Parametric: x = cx + r¬∑cos(t), y = cy + r¬∑sin(t), t ‚àà [0, 2œÄ]
       */
      circles: (ctx, w, h, color, positions = ['topLeft', 'center']) => {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        
        // Position configs - each is a field source location
        const configs = {
          topLeft: { x: 80, y: 80, r: 40 },
          topRight: { x: w - 80, y: 80, r: 40 },
          bottomLeft: { x: 80, y: h - 80, r: 35 },
          bottomRight: { x: w - 80, y: h - 80, r: 35 },
          center: { x: w / 2, y: h / 2, r: 80 },
          centerLarge: { x: w / 2, y: h / 2, r: 120 },
          centerSmall: { x: w / 2, y: h / 2, r: 50 }
        };
        
        positions.forEach(pos => {
          const cfg = configs[pos];
          if (cfg) {
            ctx.beginPath();
            // Full circle: t from 0 to 2œÄ
            ctx.arc(cfg.x, cfg.y, cfg.r, 0, Math.PI * 2);
            ctx.stroke();
          }
        });
      },
      
      /**
       * CIRCLES FILLED - Solid Radial Collapse
       * The filled variant represents field DENSITY rather than boundary
       */
      circlesFilled: (ctx, w, h, color, positions = ['center'], opacity = 0.3) => {
        ctx.fillStyle = color;
        ctx.globalAlpha = opacity;
        
        const configs = {
          topLeft: { x: 80, y: 80, r: 40 },
          topRight: { x: w - 80, y: 80, r: 40 },
          bottomLeft: { x: 80, y: h - 80, r: 35 },
          bottomRight: { x: w - 80, y: h - 80, r: 35 },
          center: { x: w / 2, y: h / 2, r: 80 },
          centerLarge: { x: w / 2, y: h / 2, r: 120 }
        };
        
        positions.forEach(pos => {
          const cfg = configs[pos];
          if (cfg) {
            ctx.beginPath();
            ctx.arc(cfg.x, cfg.y, cfg.r, 0, Math.PI * 2);
            ctx.fill();
          }
        });
        
        ctx.globalAlpha = 1;
      },
      
      /**
       * GRADIENT CIRCLES - Radial Field Intensity
       * Mathematical basis: |Œ¶(r)| = Œ¶‚ÇÄ ¬∑ e^(-r¬≤/2œÉ¬≤)
       * Gaussian falloff from center - the "glow" effect
       */
      gradientCircle: (ctx, w, h, colorInner, colorOuter, cx, cy, r) => {
        const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
        gradient.addColorStop(0, colorInner);
        gradient.addColorStop(1, colorOuter);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fill();
      },
      
      /**
       * SQUARES - Orthogonal Basis Collapse
       * Mathematical basis: max(|x-cx|, |y-cy|) = s (L‚àû metric)
       * The square is the unit ball in L‚àû norm
       */
      square: (ctx, w, h, color, positions = ['bottomLeft']) => {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        
        const configs = {
          bottomLeft: { x: 30, y: h - 80, size: 50 },
          bottomRight: { x: w - 80, y: h - 80, size: 50 },
          topLeft: { x: 30, y: 30, size: 50 },
          topRight: { x: w - 80, y: 30, size: 50 }
        };
        
        positions.forEach(pos => {
          const cfg = configs[pos];
          if (cfg) {
            ctx.strokeRect(cfg.x, cfg.y, cfg.size, cfg.size);
          }
        });
      },
      
      /**
       * SQUARES FILLED - Solid Orthogonal Density
       */
      squaresFilled: (ctx, w, h, color, positions = ['bottomLeft'], opacity = 0.3) => {
        ctx.fillStyle = color;
        ctx.globalAlpha = opacity;
        
        const configs = {
          bottomLeft: { x: 30, y: h - 80, size: 50 },
          bottomRight: { x: w - 80, y: h - 80, size: 50 },
          topLeft: { x: 30, y: 30, size: 50 },
          topRight: { x: w - 80, y: 30, size: 50 }
        };
        
        positions.forEach(pos => {
          const cfg = configs[pos];
          if (cfg) {
            ctx.fillRect(cfg.x, cfg.y, cfg.size, cfg.size);
          }
        });
        
        ctx.globalAlpha = 1;
      },
      
      /**
       * DIAGONAL LINES - ‚àáŒ¶ Direction Field at Angle Œ∏
       * 
       * THE SCALAR UNFURLING IN ACTION:
       * Input: angle (single scalar, e.g. 45)
       * 
       * Step 1: Œ∏ (degrees) ‚Üí Œ∏_rad (radians)
       * Step 2: Œ∏_rad ‚Üí (cos Œ∏, sin Œ∏) - unit direction vector
       * Step 3: Direction vector ‚Üí parametric line family
       * Step 4: Line family ‚Üí pixel coordinates across canvas
       * 
       * This is fiber bundle projection:
       * S¬π (angle circle) ‚Üí R¬≤ (canvas plane) ‚Üí Z¬≤ (pixel grid)
       * 
       * @param {number} angle - Degrees from horizontal (45 = diagonal, 90 = vertical)
       * @param {number} spacing - Distance between parallel lines
       * @param {number} thickness - Line weight
       */
      diagonalLines: (ctx, w, h, color, angle = 45, spacing = 60, thickness = 1) => {
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness;
        ctx.globalAlpha = 0.4;
        
        // SCALAR UNFURLING: angle ‚Üí radians ‚Üí direction vector
        const theta = (angle * Math.PI) / 180;
        const dx = Math.cos(theta);  // x-component of ‚àáŒ¶
        const dy = Math.sin(theta);  // y-component of ‚àáŒ¶
        
        // Perpendicular direction for line spacing
        const px = -dy;  // perpendicular x
        const py = dx;   // perpendicular y
        
        // Canvas diagonal length (maximum line extent)
        const diagonal = Math.sqrt(w * w + h * h);
        
        // Number of lines needed to cover canvas
        const numLines = Math.ceil(diagonal / spacing) * 2;
        
        // Draw parallel lines along ‚àáŒ¶ direction
        for (let i = -numLines; i <= numLines; i++) {
          // Offset along perpendicular
          const offsetX = i * spacing * px;
          const offsetY = i * spacing * py;
          
          // Center point of this line
          const cx = w / 2 + offsetX;
          const cy = h / 2 + offsetY;
          
          // Line endpoints (extend beyond canvas)
          const x1 = cx - diagonal * dx;
          const y1 = cy - diagonal * dy;
          const x2 = cx + diagonal * dx;
          const y2 = cy + diagonal * dy;
          
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
        
        ctx.globalAlpha = 1;
      },
      
      /**
       * PINSTRIPES - Dense Diagonal Field (Classic Marketing Look)
       * Same mathematics as diagonalLines but with tighter spacing
       */
      pinstripes: (ctx, w, h, color, angle = 45, spacing = 20) => {
        Decorations.diagonalLines(ctx, w, h, color, angle, spacing, 1);
      },
      
      /**
       * CROSSHATCH - Superposition of Two ‚àáŒ¶ Fields
       * Mathematical basis: F = F‚ÇÅ + F‚ÇÇ where F‚ÇÅ ‚ä• F‚ÇÇ
       * Creates interference pattern from orthogonal gradients
       */
      crosshatch: (ctx, w, h, color, angle1 = 45, angle2 = 135, spacing = 40) => {
        Decorations.diagonalLines(ctx, w, h, color, angle1, spacing, 1);
        Decorations.diagonalLines(ctx, w, h, color, angle2, spacing, 1);
      },
      
      /**
       * GRADIENT BAND - Horizontal Field Intensity Strip
       * Mathematical basis: Œ¶(y) = linear interpolation
       * Creates depth/atmosphere in specific zone
       */
      gradientBand: (ctx, w, h, color1, color2, y1, y2) => {
        const gradient = ctx.createLinearGradient(0, y1, 0, y2);
        gradient.addColorStop(0, color1);
        gradient.addColorStop(1, color2);
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, y1, w, y2 - y1);
      },
      
      /**
       * RADIAL BURST - Rays from Center Point
       * Mathematical basis: Œ∏ = constant (angular sectors)
       * Each ray is a direction of ‚àáŒ¶ emanating from source
       */
      radialBurst: (ctx, w, h, color, cx, cy, numRays = 12, innerR = 50, outerR = 150) => {
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.3;
        
        // Distribute rays evenly around circle
        const angleStep = (2 * Math.PI) / numRays;
        
        for (let i = 0; i < numRays; i++) {
          const theta = i * angleStep;
          
          // Ray from inner to outer radius
          const x1 = cx + innerR * Math.cos(theta);
          const y1 = cy + innerR * Math.sin(theta);
          const x2 = cx + outerR * Math.cos(theta);
          const y2 = cy + outerR * Math.sin(theta);
          
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
        
        ctx.globalAlpha = 1;
      },
      
      /**
       * CONCENTRIC RINGS - Multiple Radial Level Sets
       * Mathematical basis: r ‚àà {r‚ÇÅ, r‚ÇÇ, r‚ÇÉ, ...}
       * Represents equipotential surfaces of radial field
       */
      concentricRings: (ctx, w, h, color, cx, cy, radii = [40, 70, 100]) => {
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.4;
        
        radii.forEach(r => {
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.stroke();
        });
        
        ctx.globalAlpha = 1;
      },
      
      /**
       * GRID - Cartesian Coordinate Field
       * Mathematical basis: x = const and y = const level sets
       * The orthogonal basis visualization
       */
      grid: (ctx, w, h, color, spacing = 40) => {
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.15;
        
        // Vertical lines (x = constant)
        for (let x = spacing; x < w; x += spacing) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, h);
          ctx.stroke();
        }
        
        // Horizontal lines (y = constant)
        for (let y = spacing; y < h; y += spacing) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(w, y);
          ctx.stroke();
        }
        
        ctx.globalAlpha = 1;
      },
      
      /**
       * DOTS PATTERN - Discrete Field Sampling
       * Mathematical basis: Œ¶ sampled at regular lattice points
       * Each dot represents field value at that location
       */
      dots: (ctx, w, h, color, spacing = 30, radius = 2) => {
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.3;
        
        for (let x = spacing; x < w; x += spacing) {
          for (let y = spacing; y < h; y += spacing) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        ctx.globalAlpha = 1;
      },
      
      /**
       * TRIANGLES - Simplex Tessellation
       * Mathematical basis: 2-simplex tiling
       * Creates geometric pattern from triangular basis
       */
      triangles: (ctx, w, h, color, positions = ['bottomLeft']) => {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        
        const size = 40;
        const configs = {
          bottomLeft: { x: 40, y: h - 40 },
          bottomRight: { x: w - 40, y: h - 40 },
          topLeft: { x: 40, y: 40 },
          topRight: { x: w - 40, y: 40 }
        };
        
        positions.forEach(pos => {
          const cfg = configs[pos];
          if (cfg) {
            ctx.beginPath();
            ctx.moveTo(cfg.x, cfg.y);
            ctx.lineTo(cfg.x + size, cfg.y);
            ctx.lineTo(cfg.x + size/2, cfg.y - size * 0.866);
            ctx.closePath();
            ctx.stroke();
          }
        });
      },
      
      /**
       * NAVIGATION DOTS - Frame Indicator
       * Shows current frame position in sequence
       */
      navDots: (ctx, w, h, color, count = 3, activeIndex = 0) => {
        const dotRadius = 4;
        const spacing = 20;
        const totalWidth = (count - 1) * spacing;
        const startX = (w - totalWidth) / 2;
        const y = h - 40;
        
        for (let i = 0; i < count; i++) {
          ctx.beginPath();
          ctx.arc(startX + i * spacing, y, dotRadius, 0, Math.PI * 2);
          if (i === activeIndex) {
            ctx.fillStyle = color;
            ctx.fill();
          } else {
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        }
      },
      
      /**
       * DIVIDER - Horizontal Separation Line
       */
      divider: (ctx, w, y, color, width = 0.6) => {
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        const lineWidth = w * width;
        const startX = (w - lineWidth) / 2;
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(startX + lineWidth, y);
        ctx.stroke();
      },
      
      /**
       * WAVE - Sinusoidal Field Oscillation
       * Mathematical basis: y = A¬∑sin(kx + œÜ)
       * Represents wave-like field pattern
       */
      wave: (ctx, w, h, color, amplitude = 20, wavelength = 100, yOffset = null) => {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.3;
        
        const y0 = yOffset || h / 2;
        const k = (2 * Math.PI) / wavelength;  // wave number
        
        ctx.beginPath();
        ctx.moveTo(0, y0);
        
        for (let x = 0; x <= w; x += 2) {
          const y = y0 + amplitude * Math.sin(k * x);
          ctx.lineTo(x, y);
        }
        
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    };
    
    /**
     * ============================================
     * SCALAR UNFURLING DOCUMENTATION
     * ============================================
     * 
     * THE PHILOSOPHY OF SCALAR UNFURLING:
     * 
     * In Intent Tensor Theory, a "scalar" is a single number.
     * But a single number contains INFINITE potential when
     * projected through the right mathematical structure.
     * 
     * Consider: angle = 45
     * 
     * This one number unfurls through FOUR LEVELS:
     * 
     * LEVEL 0: THE SCALAR (Œ∏ = 45)
     *   - A point on the real number line
     *   - Dimensionality: 0D
     *   - Information: 1 value
     * 
     * LEVEL 1: THE PROJECTION (Œ∏ ‚Üí radians ‚Üí (cos Œ∏, sin Œ∏))
     *   - Scalar maps to unit circle point
     *   - Dimensionality: 0D ‚Üí 1D (S¬π)
     *   - This is the FIBER BUNDLE projection
     *   - Œ∏_rad = Œ∏ √ó œÄ/180 = 0.785398...
     *   - cos(45¬∞) = 0.7071..., sin(45¬∞) = 0.7071...
     *   - The scalar has become a DIRECTION VECTOR
     * 
     * LEVEL 2: THE FIELD (direction ‚Üí line family)
     *   - One direction generates infinite parallel lines
     *   - Dimensionality: 1D ‚Üí 2D (R¬≤)
     *   - Each line: p(t) = p‚ÇÄ + t¬∑(cos Œ∏, sin Œ∏)
     *   - Parameterized by offset distance from origin
     *   - The direction has become a FIELD OF LINES
     * 
     * LEVEL 3: THE RENDERING (continuous ‚Üí discrete)
     *   - Continuous lines map to pixel coordinates
     *   - Dimensionality: R¬≤ ‚Üí Z¬≤ (integer grid)
     *   - Anti-aliasing, clipping, rasterization
     *   - The field has become VISUAL REALITY
     * 
     * TOTAL TRANSFORMATION:
     *   45 ‚Üí 0.785 ‚Üí (0.707, 0.707) ‚Üí ‚àû lines ‚Üí 640√ó800 pixels
     *   1 number ‚Üí ~512,000 pixel decisions
     * 
     * This is PRE-EMERGENT VISUAL DYNAMICS:
     * The minimal seed (one scalar) contains the DNA
     * for maximum visual specification.
     * 
     * The GENIUS of ITT is recognizing that:
     * - Complex outputs need not require complex inputs
     * - Mathematical structure does the heavy lifting
     * - The scalar "knows" how to unfurl through geometry
     * 
     * In marketing terms: The Intent (Œ¶) is the scalar.
     * The campaign creative is the unfurled visual field.
     * f(x) = the mapping function between them.
     * 
     * ============================================
     */
    
    /**
     * Parse zoned layout command
     * 
     * EXTENDED SCALAR PARAMETERS:
     * - angle: Rotation angle for diagonal decorations (degrees)
     * - spacing: Distance between repeated elements (pixels)
     * - opacity: Alpha transparency (0-1)
     * - thickness: Line weight (pixels)
     * - radius: Circle/dot radius (pixels)
     * 
     * Each scalar unfurls through the decoration system
     * into rich visual patterns.
     */
    function parseZonedCommand(cmdStr) {
      const manifest = {
        layout: 'zones',
        header: null,
        headerColor: '#ffffff',
        subheader: null,
        subheaderColor: '#00ff00',
        content: [],  // Array of content frames
        tagline: null,
        taglineColor: '#cccccc',
        footer: null,
        footerColor: '#888888',
        palette: 'corporate',
        canvas: '4:5',  // Default to portrait for ads
        decorations: ['corners'],
        decorationColor: '#00ff00',
        decorationColor2: '#ffffff',  // Secondary color for gradients
        timing: 2000,
        background: 'solid',  // solid, gradient
        backgroundColor: '#1a1a1a',
        // NEW SCALAR PARAMETERS - each one unfurls into visual structure
        angle: 45,        // Rotation for diagonal elements (degrees)
        angle2: 135,      // Second angle for crosshatch
        spacing: 40,      // Distance between repeated elements
        opacity: 0.3,     // Alpha for filled/pattern elements
        thickness: 2,     // Line weight
        radius: 80,       // Circle radius for centered elements
        amplitude: 20,    // Wave amplitude
        wavelength: 100   // Wave period
      };
      
      // Numeric parameters that need conversion
      const numericParams = ['angle', 'angle2', 'spacing', 'opacity', 'thickness', 'radius', 'amplitude', 'wavelength', 'timing'];
      
      const parts = cmdStr.split('|');
      for (const part of parts) {
        const [key, ...valueParts] = part.split('=');
        const value = valueParts.join('=').trim();
        const k = key.trim();
        
        if (k === 'content') {
          // Content can be animated: content=Frame1~Frame2~Frame3
          manifest.content = value.split('~').map(s => s.trim());
        } else if (k === 'decorations') {
          // decorations=corners,circles,squares
          manifest.decorations = value.split(',').map(s => s.trim());
        } else if (k === 'timing') {
          manifest.timing = value.endsWith('s') ? parseFloat(value) * 1000 : parseFloat(value);
        } else if (numericParams.includes(k)) {
          // Convert numeric scalars - THE UNFURLING BEGINS HERE
          manifest[k] = parseFloat(value);
        } else if (manifest.hasOwnProperty(k)) {
          manifest[k] = value;
        }
      }
      
      return manifest;
    }
    
    /**
     * ============================================
     * RENDER ZONED FRAME
     * 
     * This is where SCALAR UNFURLING becomes VISUAL REALITY.
     * 
     * Each parameter in the manifest is a seed scalar.
     * This function is the projection operator that maps:
     *   Scalar Space ‚Üí Visual Space
     * 
     * The rendering order is critical (back to front):
     * 1. Background (Œ¶‚ÇÄ - the ground state)
     * 2. Pattern decorations (‚àáŒ¶ - field directions)
     * 3. Shape decorations (‚àá¬≤Œ¶ - collapse points)
     * 4. Text zones (Œ® - the offer state vectors)
     * 5. Navigation (feedback indicators)
     * 
     * ============================================
     */
    function renderZonedFrame(manifest, contentIndex = 0) {
      const canvasSize = CANVAS_SIZES[manifest.canvas] || CANVAS_SIZES['4:5'];
      const { width: w, height: h } = canvasSize;
      
      canvas.width = w;
      canvas.height = h;
      
      // Get palette colors
      const palette = PALETTES[manifest.palette] || PALETTES.corporate;
      
      // Extract scalar parameters for unfurling
      const {
        decorationColor: decoColor,
        decorationColor2: decoColor2,
        angle,
        angle2,
        spacing,
        opacity,
        thickness,
        radius,
        amplitude,
        wavelength
      } = manifest;
      
      // === LAYER 0: BACKGROUND (Œ¶‚ÇÄ Ground State) ===
      if (manifest.background === 'gradient') {
        const gradient = ctx.createLinearGradient(0, 0, w, h);
        palette.gradient.forEach((color, i) => {
          gradient.addColorStop(i / (palette.gradient.length - 1), color);
        });
        ctx.fillStyle = gradient;
      } else {
        ctx.fillStyle = manifest.backgroundColor;
      }
      ctx.fillRect(0, 0, w, h);
      
      // === LAYER 1: PATTERN DECORATIONS (‚àáŒ¶ Field Patterns) ===
      // These are continuous field visualizations - drawn first (behind shapes)
      
      // Grid: Cartesian basis field
      if (manifest.decorations.includes('grid')) {
        Decorations.grid(ctx, w, h, decoColor, spacing);
      }
      
      // Dots: Discrete field sampling
      if (manifest.decorations.includes('dots')) {
        Decorations.dots(ctx, w, h, decoColor, spacing, 2);
      }
      
      // Diagonal lines: ‚àáŒ¶ at angle Œ∏
      // THE SCALAR UNFURLING: angle ‚Üí direction ‚Üí line family ‚Üí pixels
      if (manifest.decorations.includes('diagonals')) {
        Decorations.diagonalLines(ctx, w, h, decoColor, angle, spacing, thickness);
      }
      
      // Pinstripes: Dense diagonal field
      if (manifest.decorations.includes('pinstripes')) {
        Decorations.pinstripes(ctx, w, h, decoColor, angle, spacing);
      }
      
      // Crosshatch: Superposition of two ‚àáŒ¶ fields
      if (manifest.decorations.includes('crosshatch')) {
        Decorations.crosshatch(ctx, w, h, decoColor, angle, angle2, spacing);
      }
      
      // Wave: Sinusoidal oscillation
      if (manifest.decorations.includes('wave')) {
        Decorations.wave(ctx, w, h, decoColor, amplitude, wavelength);
      }
      
      // === LAYER 2: FILLED SHAPES (Field Density) ===
      // These represent field MAGNITUDE, not boundary
      
      // Gradient circle at center: Radial field intensity |Œ¶(r)|
      if (manifest.decorations.includes('glow')) {
        const transparent = decoColor + '00';  // Add alpha
        Decorations.gradientCircle(ctx, w, h, decoColor, transparent, w/2, h/2, radius);
      }
      
      // Filled circles: Solid field regions
      if (manifest.decorations.includes('circlesFilled')) {
        Decorations.circlesFilled(ctx, w, h, decoColor, ['center'], opacity);
      }
      
      // Filled squares: Orthogonal density regions
      if (manifest.decorations.includes('squaresFilled')) {
        Decorations.squaresFilled(ctx, w, h, decoColor, ['bottomLeft', 'bottomRight'], opacity);
      }
      
      // === LAYER 3: OUTLINE SHAPES (‚àá¬≤Œ¶ Collapse Boundaries) ===
      // These are where the field concentrates - drawn on top
      
      // Corner brackets: Boundary collapse at vertices
      if (manifest.decorations.includes('corners')) {
        Decorations.corners(ctx, w, h, decoColor, thickness);
      }
      
      // Outline circles: Radial level sets
      if (manifest.decorations.includes('circles')) {
        Decorations.circles(ctx, w, h, decoColor, ['topLeft', 'center']);
      }
      
      // Outline squares: L‚àû metric boundaries
      if (manifest.decorations.includes('squares')) {
        Decorations.square(ctx, w, h, decoColor, ['bottomLeft', 'bottomRight']);
      }
      
      // Triangles: Simplex boundaries
      if (manifest.decorations.includes('triangles')) {
        Decorations.triangles(ctx, w, h, decoColor, ['bottomLeft', 'bottomRight']);
      }
      
      // Concentric rings: Multiple radial level sets
      if (manifest.decorations.includes('rings')) {
        Decorations.concentricRings(ctx, w, h, decoColor, w/2, h/2, [40, 70, 100, 130]);
      }
      
      // Radial burst: Ray field from center
      if (manifest.decorations.includes('burst')) {
        Decorations.radialBurst(ctx, w, h, decoColor, w/2, h/2, 12, 50, 150);
      }
      
      // === LAYER 4: TEXT ZONES (Œ® Offer State Vectors) ===
      ctx.textAlign = 'center';
      
      // Zone Y positions (proportional to canvas height)
      // These are the FIXED POINTS in the visual field
      const headerY = h * 0.20;
      const subheaderY = h * 0.32;
      const contentY = h * 0.48;
      const taglineY = h * 0.62;
      const footerY = h * 0.72;
      
      // HEADER (fixed, large, bold) - The Brand Anchor
      if (manifest.header) {
        ctx.fillStyle = manifest.headerColor;
        ctx.font = `800 ${Math.floor(w * 0.10)}px 'SF Mono', 'Courier New', monospace`;
        ctx.fillText(manifest.header, w / 2, headerY);
      }
      
      // Divider line after header
      if (manifest.header && manifest.subheader) {
        Decorations.divider(ctx, w, headerY + 25, decoColor, 0.5);
      }
      
      // SUBHEADER (fixed, colored, medium) - The Category Signal
      if (manifest.subheader) {
        ctx.fillStyle = manifest.subheaderColor;
        ctx.font = `400 ${Math.floor(w * 0.07)}px Inter, -apple-system, sans-serif`;
        ctx.fillText(manifest.subheader, w / 2, subheaderY);
      }
      
      // CONTENT (animated zone!) - The Dynamic Attractor
      // This is where temporal collapse happens across frames
      if (manifest.content.length > 0) {
        const currentContent = manifest.content[contentIndex % manifest.content.length];
        ctx.fillStyle = palette.text || '#ffffff';
        ctx.font = `600 ${Math.floor(w * 0.055)}px Inter, -apple-system, sans-serif`;
        
        // Wrap content text
        const lines = wrapText(ctx, currentContent, w * 0.8);
        const lineHeight = Math.floor(w * 0.07);
        const startY = contentY - ((lines.length - 1) * lineHeight) / 2;
        
        lines.forEach((line, i) => {
          ctx.fillText(line, w / 2, startY + i * lineHeight);
        });
      }
      
      // TAGLINE (fixed, smaller) - The Value Proposition
      if (manifest.tagline) {
        ctx.fillStyle = manifest.taglineColor;
        ctx.font = `400 ${Math.floor(w * 0.04)}px Inter, -apple-system, sans-serif`;
        ctx.fillText(manifest.tagline, w / 2, taglineY);
      }
      
      // FOOTER (fixed, small, muted) - The Trust Anchor
      if (manifest.footer) {
        ctx.fillStyle = manifest.footerColor;
        ctx.font = `400 ${Math.floor(w * 0.035)}px Inter, -apple-system, sans-serif`;
        ctx.fillText(manifest.footer, w / 2, footerY);
      }
      
      // Navigation dots (show which frame we're on)
      if (manifest.content.length > 1) {
        Decorations.navDots(ctx, w, h, decoColor, manifest.content.length, contentIndex);
      }
      
      return ctx.getImageData(0, 0, w, h);
    }
    
    class GifEncoder {
      constructor(width, height) {
        this.width = width;
        this.height = height;
        this.rawFrames = []; // Store raw ImageData
        this.delays = [];
        this.globalPalette = null;
        this.paletteColors = null;
      }
      
      addFrame(imageData, delay) {
        this.rawFrames.push(imageData);
        this.delays.push(Math.round(delay / 10));
      }
      
      // Build unified palette from ALL frames
      buildGlobalPalette() {
        const colorCounts = new Map();
        
        // Collect colors from ALL frames
        for (const imageData of this.rawFrames) {
          const pixels = imageData.data;
          for (let i = 0; i < pixels.length; i += 4) {
            // Less aggressive reduction (6 bits instead of 5)
            const r = pixels[i] & 0xFC;
            const g = pixels[i + 1] & 0xFC;
            const b = pixels[i + 2] & 0xFC;
            const key = (r << 16) | (g << 8) | b;
            colorCounts.set(key, (colorCounts.get(key) || 0) + 1);
          }
        }
        
        // Get top 256 colors across all frames
        const sortedColors = [...colorCounts.entries()]
          .sort((a, b) => b[1] - a[1])
          .slice(0, 256)
          .map(([color]) => color);
        
        // Pad to 256 colors with gradients for smoother fallback
        while (sortedColors.length < 256) {
          const idx = sortedColors.length;
          // Fill with grayscale ramp
          const gray = idx & 0xFC;
          sortedColors.push((gray << 16) | (gray << 8) | gray);
        }
        
        this.paletteColors = sortedColors;
        
        // Build palette bytes
        const palette = new Uint8Array(256 * 3);
        for (let i = 0; i < 256; i++) {
          const color = sortedColors[i];
          palette[i * 3] = (color >> 16) & 0xFF;
          palette[i * 3 + 1] = (color >> 8) & 0xFF;
          palette[i * 3 + 2] = color & 0xFF;
        }
        
        this.globalPalette = palette;
        
        // Build fast lookup
        this.colorLookup = new Map();
        sortedColors.forEach((color, index) => {
          this.colorLookup.set(color, index);
        });
      }
      
      // Map frame pixels to palette indices
      quantizeFrame(imageData) {
        const pixels = imageData.data;
        const indices = new Uint8Array(this.width * this.height);
        
        for (let i = 0, j = 0; i < pixels.length; i += 4, j++) {
          const r = pixels[i] & 0xFC;
          const g = pixels[i + 1] & 0xFC;
          const b = pixels[i + 2] & 0xFC;
          const key = (r << 16) | (g << 8) | b;
          
          if (this.colorLookup.has(key)) {
            indices[j] = this.colorLookup.get(key);
          } else {
            // Find nearest color with fast approximation
            let minDist = Infinity;
            let nearest = 0;
            
            // Only check first 128 colors for speed (most common ones)
            const checkCount = Math.min(128, this.paletteColors.length);
            for (let k = 0; k < checkCount; k++) {
              const pc = this.paletteColors[k];
              const pr = (pc >> 16) & 0xFF;
              const pg = (pc >> 8) & 0xFF;
              const pb = pc & 0xFF;
              // Weighted distance (human eye more sensitive to green)
              const dist = (r - pr) ** 2 * 2 + (g - pg) ** 2 * 4 + (b - pb) ** 2;
              if (dist < minDist) {
                minDist = dist;
                nearest = k;
              }
            }
            indices[j] = nearest;
          }
        }
        
        return indices;
      }
      
      // LZW encode
      lzwEncode(indices, minCodeSize) {
        const clearCode = 1 << minCodeSize;
        const endCode = clearCode + 1;
        
        let codeSize = minCodeSize + 1;
        let nextCode = endCode + 1;
        const maxCode = 4096;
        
        const dictionary = new Map();
        for (let i = 0; i < clearCode; i++) {
          dictionary.set(String.fromCharCode(i), i);
        }
        
        const output = [];
        let bits = 0;
        let bitCount = 0;
        
        const writeBits = (code, size) => {
          bits |= code << bitCount;
          bitCount += size;
          while (bitCount >= 8) {
            output.push(bits & 0xFF);
            bits >>= 8;
            bitCount -= 8;
          }
        };
        
        writeBits(clearCode, codeSize);
        
        if (indices.length === 0) {
          writeBits(endCode, codeSize);
          if (bitCount > 0) output.push(bits & 0xFF);
          return new Uint8Array(output);
        }
        
        let current = String.fromCharCode(indices[0]);
        
        for (let i = 1; i < indices.length; i++) {
          const next = String.fromCharCode(indices[i]);
          const combined = current + next;
          
          if (dictionary.has(combined)) {
            current = combined;
          } else {
            writeBits(dictionary.get(current), codeSize);
            
            if (nextCode < maxCode) {
              dictionary.set(combined, nextCode++);
              if (nextCode > (1 << codeSize) && codeSize < 12) {
                codeSize++;
              }
            } else {
              writeBits(clearCode, codeSize);
              codeSize = minCodeSize + 1;
              nextCode = endCode + 1;
              dictionary.clear();
              for (let j = 0; j < clearCode; j++) {
                dictionary.set(String.fromCharCode(j), j);
              }
            }
            
            current = next;
          }
        }
        
        writeBits(dictionary.get(current), codeSize);
        writeBits(endCode, codeSize);
        
        if (bitCount > 0) {
          output.push(bits & 0xFF);
        }
        
        return new Uint8Array(output);
      }
      
      encode() {
        // First, build unified palette from all frames
        console.log(`üìä Building palette from ${this.rawFrames.length} frames...`);
        this.buildGlobalPalette();
        console.log(`üìä Palette built: ${this.paletteColors.length} colors`);
        
        const chunks = [];
        
        // GIF Header
        chunks.push(new Uint8Array([0x47, 0x49, 0x46, 0x38, 0x39, 0x61])); // GIF89a
        
        // Logical Screen Descriptor
        const lsd = new Uint8Array(7);
        lsd[0] = this.width & 0xFF;
        lsd[1] = (this.width >> 8) & 0xFF;
        lsd[2] = this.height & 0xFF;
        lsd[3] = (this.height >> 8) & 0xFF;
        lsd[4] = 0xF7; // Global color table, 256 colors (2^(7+1))
        lsd[5] = 0; // Background color index
        lsd[6] = 0; // Pixel aspect ratio
        chunks.push(lsd);
        
        // Global Color Table
        chunks.push(this.globalPalette);
        
        // Netscape extension for looping
        chunks.push(new Uint8Array([
          0x21, 0xFF, 0x0B,
          0x4E, 0x45, 0x54, 0x53, 0x43, 0x41, 0x50, 0x45, // NETSCAPE
          0x32, 0x2E, 0x30, // 2.0
          0x03, 0x01,
          0x00, 0x00, // Loop count (0 = infinite)
          0x00
        ]));
        
        // Add each frame
        for (let f = 0; f < this.rawFrames.length; f++) {
          const imageData = this.rawFrames[f];
          const delay = this.delays[f];
          
          console.log(`  Encoding frame ${f + 1}/${this.rawFrames.length}, delay=${delay * 10}ms`);
          
          // Quantize this frame using global palette
          const indices = this.quantizeFrame(imageData);
          
          // Graphic Control Extension
          const gce = new Uint8Array(8);
          gce[0] = 0x21; // Extension introducer
          gce[1] = 0xF9; // Graphic control label
          gce[2] = 0x04; // Block size
          gce[3] = 0x04; // Disposal method 1 (do not dispose) = bits 4-2 = 001 = 0x04
          gce[4] = delay & 0xFF;
          gce[5] = (delay >> 8) & 0xFF;
          gce[6] = 0x00; // Transparent color index
          gce[7] = 0x00; // Block terminator
          chunks.push(gce);
          
          // Image Descriptor
          const id = new Uint8Array(10);
          id[0] = 0x2C; // Image separator
          id[1] = 0; id[2] = 0; // Left
          id[3] = 0; id[4] = 0; // Top
          id[5] = this.width & 0xFF;
          id[6] = (this.width >> 8) & 0xFF;
          id[7] = this.height & 0xFF;
          id[8] = (this.height >> 8) & 0xFF;
          id[9] = 0x00; // No local color table
          chunks.push(id);
          
          // LZW Minimum Code Size
          chunks.push(new Uint8Array([0x08]));
          
          // LZW Data
          const lzwData = this.lzwEncode(indices, 8);
          
          // Split into sub-blocks (max 255 bytes each)
          let offset = 0;
          while (offset < lzwData.length) {
            const blockSize = Math.min(255, lzwData.length - offset);
            chunks.push(new Uint8Array([blockSize]));
            chunks.push(lzwData.slice(offset, offset + blockSize));
            offset += blockSize;
          }
          
          // Block terminator
          chunks.push(new Uint8Array([0x00]));
        }
        
        // GIF Trailer
        chunks.push(new Uint8Array([0x3B]));
        
        // Combine all chunks
        const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
        const result = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
          result.set(chunk, offset);
          offset += chunk.length;
        }
        
        return result;
      }
      
      toDataURL() {
        const bytes = this.encode();
        let binary = '';
        for (let i = 0; i < bytes.length; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return 'data:image/gif;base64,' + btoa(binary);
      }
    }

    /**
     * Generate animated GIF from frames
     */
    async function generateAnimatedGIF(frames, width, height) {
      try {
        console.log(`üé¨ GIF Encoder: ${frames.length} frames, ${width}x${height}`);
        
        // Verify frames are unique by checking first 100 pixels
        const frameHashes = [];
        for (let i = 0; i < frames.length; i++) {
          const data = frames[i].imageData.data;
          let hash = 0;
          for (let j = 0; j < Math.min(400, data.length); j++) {
            hash = ((hash << 5) - hash + data[j]) | 0;
          }
          frameHashes.push(hash);
          console.log(`  Frame ${i + 1}: delay=${frames[i].delay}ms, hash=${hash}, first pixels: R=${data[0]},G=${data[1]},B=${data[2]}`);
        }
        
        // Check if all frames are identical
        const uniqueHashes = new Set(frameHashes);
        if (uniqueHashes.size === 1) {
          console.warn('‚ö†Ô∏è WARNING: All frames appear identical!');
        } else {
          console.log(`‚úì Frames verified unique: ${uniqueHashes.size} distinct frames`);
        }
        
        const encoder = new GifEncoder(width, height);
        
        for (const frame of frames) {
          encoder.addFrame(frame.imageData, frame.delay);
        }
        
        console.log('üîß Building global palette from all frames...');
        const result = encoder.toDataURL();
        console.log(`‚úÖ GIF encoded: ${result.length} chars`);
        console.log(`   Type check: starts with "data:image/gif" = ${result.startsWith('data:image/gif')}`);
        
        return result;
      } catch (error) {
        console.error('GIF encoding error:', error);
        return canvas.toDataURL('image/png');
      }
    }

    /**
     * Generate GIF from canvas (single frame fallback)
     */
    async function generateGIF(canvas) {
      return canvas.toDataURL('image/png');
    }

    /**
     * Main execution pipeline
     * Supports: single-frame, multi-frame sequences, and zone-based layouts
     */
    async function execute(cmdStr) {
      try {
        // 1. Parse
        statusEl.className = 'status info';
        statusEl.textContent = '‚öôÔ∏è Parsing command...';
        
        // Detect layout type
        const isZonedLayout = cmdStr.includes('header=') || cmdStr.includes('layout=zones');
        
        if (isZonedLayout) {
          // === ZONE-BASED LAYOUT ===
          console.log('üèóÔ∏è Zone-based layout detected');
          const manifest = parseZonedCommand(cmdStr);
          console.log('üìù Zoned manifest:', manifest);
          
          const frameCount = Math.max(1, manifest.content.length);
          const canvasSize = CANVAS_SIZES[manifest.canvas] || CANVAS_SIZES['4:5'];
          
          if (frameCount > 1) {
            // Multi-frame zoned animation
            statusEl.textContent = `üé¨ Rendering ${frameCount} zoned frames...`;
            const frames = [];
            
            for (let i = 0; i < frameCount; i++) {
              statusEl.textContent = `üé¨ Rendering zone frame ${i + 1}/${frameCount}...`;
              const imageData = renderZonedFrame(manifest, i);
              frames.push({
                imageData: imageData,
                delay: manifest.timing
              });
              await new Promise(r => setTimeout(r, 30));
            }
            
            // Show last frame in preview
            renderZonedFrame(manifest, frameCount - 1);
            
            // Generate animated GIF
            statusEl.textContent = 'üì¶ Encoding zoned GIF...';
            gifData = await generateAnimatedGIF(frames, canvasSize.width, canvasSize.height);
            
            const duration = (frameCount * manifest.timing / 1000).toFixed(1);
            statusEl.className = 'status success';
            statusEl.textContent = `‚úì Zoned GIF ready! ${frameCount} frames, ${duration}s duration`;
            
          } else {
            // Single-frame zoned layout
            statusEl.textContent = 'üé® Rendering zoned layout...';
            renderZonedFrame(manifest, 0);
            gifData = canvas.toDataURL('image/png');
            
            statusEl.className = 'status success';
            statusEl.textContent = `‚úì Zoned image ready!`;
          }
          
          return;
        }
        
        // === STANDARD LAYOUT (existing code) ===
        const manifest = parseCommand(cmdStr);
        console.log('üìù Parsed:', manifest);
        
        // 2. Emerge base specification
        statusEl.textContent = 'üåÄ Emerging specification...';
        const spec = emerge(manifest);
        console.log('üìã Emerged:', spec);
        currentManifest = spec;
        
        // Check if this is a multi-frame sequence
        const isSequence = manifest.sequence && manifest.sequence.length > 1;
        
        if (isSequence) {
          // MULTI-FRAME SEQUENCE
          statusEl.textContent = `üé¨ Rendering ${manifest.sequence.length} frames...`;
          
          const frames = [];
          const { dimensions } = spec;
          
          // Render each frame in sequence
          for (let i = 0; i < manifest.sequence.length; i++) {
            const frameText = manifest.sequence[i].replace(/\\n/g, '\n');
            statusEl.textContent = `üé¨ Rendering frame ${i + 1}/${manifest.sequence.length}: "${frameText.substring(0, 20)}..."`;
            
            const imageData = renderFrame(spec, frameText);
            frames.push({
              imageData: imageData,
              delay: manifest.timing
            });
            
            // Small delay to allow UI update
            await new Promise(r => setTimeout(r, 50));
          }
          
          // Show last frame in preview
          renderFrame(spec, manifest.sequence[manifest.sequence.length - 1].replace(/\\n/g, '\n'));
          
          // Generate animated GIF
          statusEl.textContent = 'üì¶ Encoding animated GIF...';
          try {
            gifData = await generateAnimatedGIF(frames, dimensions.width, dimensions.height);
            
            const bytes = Math.round(gifData.length * 0.75);
            const duration = (manifest.sequence.length * manifest.timing / 1000).toFixed(1);
            statusEl.className = 'status success';
            statusEl.textContent = `‚úì Animated GIF ready! ${manifest.sequence.length} frames, ${duration}s duration`;
          } catch (gifError) {
            console.warn('GIF encoding failed, using PNG:', gifError);
            gifData = canvas.toDataURL('image/png');
            statusEl.className = 'status success';
            statusEl.textContent = `‚úì PNG ready (GIF encoding unavailable). ${manifest.sequence.length} frames designed.`;
          }
          
        } else {
          // SINGLE FRAME
          statusEl.textContent = 'üé® Rendering...';
          render(spec);
          
          // Generate single frame
          statusEl.textContent = 'üì¶ Generating image...';
          gifData = await generateGIF(canvas);
          
          const bytes = Math.round(gifData.length * 0.75);
          statusEl.className = 'status success';
          statusEl.textContent = `‚úì Image ready! ${bytes.toLocaleString()} bytes, 1 frame`;
        }
        
      } catch (error) {
        console.error('Error:', error);
        statusEl.className = 'status error';
        statusEl.textContent = `‚úó Error: ${error.message}`;
      }
    }

    /**
     * Download current GIF/PNG
     */
    function download() {
      if (!gifData) {
        statusEl.className = 'status error';
        statusEl.textContent = '‚úó No image to download. Render first!';
        return;
      }
      
      // Detect file type from data URL
      const isGif = gifData.startsWith('data:image/gif');
      const ext = isGif ? 'gif' : 'png';
      
      console.log(`üì• Downloading as .${ext}`);
      console.log(`   Data URL length: ${gifData.length}`);
      console.log(`   Starts with: ${gifData.substring(0, 30)}`);
      
      const link = document.createElement('a');
      link.download = `dynamic-gif-${Date.now()}.${ext}`;
      link.href = gifData;
      document.body.appendChild(link); // Required for Firefox
      link.click();
      document.body.removeChild(link);
      
      console.log(`‚úì Download triggered: ${link.download}`);
    }

    // Event Listeners
    commandInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const cmd = commandInput.value.trim();
        if (cmd) execute(cmd);
      }
    });

    renderBtn.addEventListener('click', () => {
      const cmd = commandInput.value.trim();
      if (cmd) execute(cmd);
    });

    downloadBtn.addEventListener('click', download);

    // Quick example click handlers
    document.querySelectorAll('.example-item').forEach(item => {
      item.addEventListener('click', () => {
        const cmd = item.dataset.cmd;
        commandInput.value = cmd;
        execute(cmd);
      });
    });

    // URL parameter support
    function loadFromURL() {
      const hash = window.location.hash.slice(1);
      if (hash) {
        const cmd = decodeURIComponent(hash);
        commandInput.value = cmd;
        execute(cmd);
      }
    }

    // Initialize
    console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                              ‚ïë
‚ïë        DYNAMIC GIF COMMAND-LINE v1.1                         ‚ïë
‚ïë        URL ‚Üí Manifest ‚Üí Emergence ‚Üí GIF                      ‚ïë
‚ïë                                                              ‚ïë
‚ïë        Built on Intent Tensor Theory                         ‚ïë
‚ïë        Pre-Emergent Visual Dynamics                          ‚ïë
‚ïë                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    `);
    
    loadFromURL();
  </script>
</body>
</html>
